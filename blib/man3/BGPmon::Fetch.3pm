.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "BGPmon::Fetch 3"
.TH BGPmon::Fetch 3 "2013-11-01" "perl v5.16.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
BGPmon::Fetch.pm
.PP
The BGPmon Fetch module, to connect to a live BGPmon stream,
an online archive of XFB data, or a single XML file.  The interface then
supports "streaming" of XML messages from the given data source.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
The BGPmon::Fetch module provides functionality to connect to one of the
following data sources:
    1) a live BGPmon instance
    2) an archive of \s-1XFB\s0 data
    3) an individual \s-1XML\s0 file
The user is then able to read \s-1XML\s0 messages in sequence from the appropriate
data source and get information about the currently-running connection.
.PP
.Vb 12
\&    use BGPmon::Fetch;
\&    my $ret = init_bgpdata();
\&    my $ret = connect_bgpdata();
\&    my $xml_msg = read_xml_message();
\&    if ( !defined($xml_msg) ){
\&        print get_error_code() . ": " . get_error_msg();
\&    }
\&    my $ret = is_connected();
\&    my $num_read = messages_read();
\&    my $uptime = uptime();
\&    my $ret = close_connection();
\&    my $downtime = connection_endtime();
.Ve
.SH "EXPORT"
.IX Header "EXPORT"
init_bgpdata
connect_bgpdata
read_xml_message
close_connection
is_connected
messages_read
uptime
connection_endtime
get_error_code
get_error_message
get_error_msg
.SH "SUBROUTINES/METHODS"
.IX Header "SUBROUTINES/METHODS"
.SS "init_bgpdata"
.IX Subsection "init_bgpdata"
Initialize parameters for any/all of the Fetch submodules.
File and Archive take the same three optional parameters:
.PP
.Vb 2
\&    scratch_dir \- a filesystem location to put a scratch directory in
\&        (default is /tmp)
\&
\&    ignore_incomplete_data \- a flag to turn off checking for possible gaps
\&        in the data "stream" (default is to check)
\&
\&    ignore_data_errors \- a flag to turn off checking for any other errors
\&        in the data. Using this flag requires setting ignore_incomplete_data.
\&        (default is to check)
.Ve
.PP
Client also accepts the same scratch directory argument described above,
but will ignore the data-integrity flags, as a live stream is, well, live.
.PP
Usage:      my \f(CW$ret\fR = init_bgpdata('scratch_dir' => '/tmp',
                                    'ignore_incomplete_data' => 1,
                                    'ignore_data_errors' => 0);
            my \f(CW$ret\fR = \fIinit_bgpdata()\fR;
            my \f(CW$ret\fR = init_bgpdata('scratch_dir' => \*(L"~/\*(R");
.SS "connect_bgpdata"
.IX Subsection "connect_bgpdata"
This is a function which connects to the appropriate data source.
If a live data source is specified, the function opens a \s-1TCP\s0 connection to the
source. If an archived data source is specified, the function processes data
files from the given \s-1URL\s0.  If a local file is specified, it will read data
from the file.
.PP
Input:  One of the following sets of arguments:
        [server_address, listening port]    \-> this will connect to live data
        [\s-1URL\s0,start time, end time]          \-> this will connect to an archive
        [filename]                          \-> this will connect to a file
.PP
Output: 1 on failure
.SS "read_xml_message"
.IX Subsection "read_xml_message"
This function reads and returns the next \s-1XML\s0 message from the currently
connected data source, or undef if there is an error \s-1OR\s0 there are no
more messages available (in File or Archive).
.PP
Usage:  my \f(CW$msg\fR = \fIread_xml_message()\fR;
.SS "close_connection"
.IX Subsection "close_connection"
This subroutine closes an active connection.  For File and Archive, this will
delete the scratch directory and close any open files.  For a live stream,
the \s-1TCP\s0 connection will be terminated.  The function returns 0 on success,
1 on failure
.PP
Usage: \fIclose_connection()\fR;
.SS "is_connected"
.IX Subsection "is_connected"
Subroutine that simply returns whether or not there is a currently-active
connection.  If no connection has been initialized, returns undef.
.PP
Usage:  if( is_connected ) { #Do stuff }
.SS "messages_read"
.IX Subsection "messages_read"
Returns the number of messages read from the data source.  This also includes
any additional metadata messages that may be in the stream or within files.
.PP
Usage:  my \f(CW$num_msgs\fR = \fImessages_read()\fR;
.SS "uptime"
.IX Subsection "uptime"
Returns number of seconds the connection has been up.
If the connection is down or there has never been a connection, return 0.
.PP
Usage:  my \f(CW$up\fR = \fIuptime()\fR;
.SS "connection_endtime"
.IX Subsection "connection_endtime"
Returns the time the connection ended.
If the connection is up, return 0.
If there has been no connection, returns \-1.
.PP
Usage:  my \f(CW$e_time\fR = \fIconnection_endtime()\fR;
.SS "get_error_code"
.IX Subsection "get_error_code"
Get the error code for a given function
Input : the name of the function whose error code we should report
Output: the function's error code
        or \s-1ARGUMENT_ERROR\s0 if the user did not supply a function
        or \s-1INVALID_FUNCTION_SPECIFIED\s0 if the user provided an invalid function
Usage:  my \f(CW$err_code\fR = get_error_code(\*(L"connect_archive\*(R");
.SS "get_error_message"
.IX Subsection "get_error_message"
Get the error message of a given function
Input : the name of the function whose error message we should report
Output: the function's error message
        or \s-1ARGUMENT_ERROR\s0 if the user did not supply a function
        or \s-1INVALID_FUNCTION_SPECIFIED\s0 if the user provided an invalid function
Usage:  my \f(CW$err_msg\fR = get_error_message(\*(L"read_xml_message\*(R");
.SS "get_error_msg"
.IX Subsection "get_error_msg"
Shorthand call for get_error_message
.SH "ERROR CODES AND MESSAGES"
.IX Header "ERROR CODES AND MESSAGES"
The following error codes and messages are defined for the Fetch module.
Additional error codes and messages are defined within Client, File,
and Archive, and can be inspected by running perldoc on each of them.
.PP
File uses Error codes 300\-399
Archive uses Error codes 400\-499
Client uses Error codes 500\-599
.PP
.Vb 2
\&    0:      No Error
\&            \*(AqNo Error. Life is good.\*(Aq
\&
\&    101:    Too many or too few arguments were passed to connect_bgpdata or
\&                get_error_[code/message/msg]
\&            \*(AqInvalid number of arguments\*(Aq
\&
\&    102:    There is no connection (via connect_bgpdata) to a data source.
\&            \*(AqNot connected to a data source\*(Aq
\&
\&    103:    An invalid function name was passed to get_error_[code/message/msg]
\&            \*(AqInvalid function name specified\*(Aq
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Kaustubh Gadkari, \f(CW\*(C`<kaustubh at cs.colostate.edu>\*(C'\fR
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs or feature requests to
\&\f(CW\*(C`bgpmon at netsec.colostate.edu\*(C'\fR, or through
the web interface at <http://bgpmon.netsec.colostate.edu>.
.SH "SUPPORT"
.IX Header "SUPPORT"
You can find documentation for this module with the perldoc command.
.PP
.Vb 1
\&    perldoc BGPmon::Fetch
.Ve
.SH "LICENSE AND COPYRIGHT"
.IX Header "LICENSE AND COPYRIGHT"
Copyright (c) 2012 Colorado State University
.PP
.Vb 8
\&    Permission is hereby granted, free of charge, to any person
\&    obtaining a copy of this software and associated documentation
\&    files (the "Software"), to deal in the Software without
\&    restriction, including without limitation the rights to use,
\&    copy, modify, merge, publish, distribute, sublicense, and/or
\&    sell copies of the Software, and to permit persons to whom
\&    the Software is furnished to do so, subject to the following
\&    conditions:
\&
\&    The above copyright notice and this permission notice shall be
\&    included in all copies or substantial portions of the Software.
\&
\&    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
\&    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
\&    OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
\&    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
\&    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
\&    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
\&    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
\&    OTHER DEALINGS IN THE SOFTWARE.\e
\&
\&    File: Fetch.pm
\&
\&    Authors: M. Lawrence Weikum, Kaustubh Gadkari, Dan Massey, Cathie Olschanowsky, Jason Bartlett
\&    Date: 13 October 2013
.Ve
